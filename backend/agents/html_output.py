import base64
import json
import logging
import mimetypes
import re
from collections import defaultdict
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple
from uuid import UUID

from ..schemas.html_schemas import (Asset, AssetType, HTMLGenerationRequest,
                                    HTMLGenerationResult, HTMLOutput,
                                    HTMLTemplate, HTMLValidationResult)
from ..schemas.message_schemas import AgentResponse, AgentTask
from .base_agent import BaseAgent


class HTMLOutputAgent(BaseAgent):
    """Agent responsible for generating self-contained HTML output."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.templates = self._load_templates()
        self.default_assets = self._load_default_assets()

    async def process_task(self, task: AgentTask) -> AgentResponse:
        """
        Process an HTML generation task.
        Args:
            task: The task containing HTML generation request
        Returns:
            AgentResponse: The generated HTML output
        """
        try:
            # Extract HTML generation request from task
            request = task.task_data.get("request")
            if not request:
                raise ValueError("Missing HTML generation request")

            # Generate HTML output
            output = await self._generate_html(request)

            # Validate output
            validation_result = self._validate_html(output)

            # Create generation result
            result = HTMLGenerationResult(
                request_id=request.module_id,
                status="completed",
                output=output,
                completed_at=datetime.utcnow(),
            )

            return AgentResponse(
                task_id=task.message_id, result=result.dict(), error=None
            )

        except Exception as e:
            self.logger.error(f"HTML generation failed: {str(e)}")
            return AgentResponse(task_id=task.message_id, result=None, error=str(e))

    def _load_templates(self) -> Dict[str, HTMLTemplate]:
        """Load HTML templates."""
        return {
            "default": HTMLTemplate(
                name="Default Template",
                description="A clean, responsive template for educational content",
                content="""
                    <!DOCTYPE html>
                    <html lang="en">
                    <head>
                        <meta charset="UTF-8">
                        <meta name="viewport" content="width=device-width, initial-scale=1.0">
                        <title>{title}</title>
                        {styles}
                    </head>
                    <body>
                        <div class="container">
                            <header>
                                <h1>{title}</h1>
                                <nav>{navigation}</nav>
                            </header>
                            <main>
                                {content}
                            </main>
                            <footer>
                                <p>Generated by AI-Powered Educational Content Generator</p>
                            </footer>
                        </div>
                        {scripts}
                    </body>
                    </html>
                """,
            )
        }

    def _load_default_assets(self) -> Dict[AssetType, List[Asset]]:
        """Load default assets for HTML output."""
        return {
            AssetType.CSS: [
                Asset(
                    type=AssetType.CSS,
                    content="""
                        /* Reset and base styles */
                        * {
                            margin: 0;
                            padding: 0;
                            box-sizing: border-box;
                        }

                        body {
                            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
                            line-height: 1.6;
                            color: #333;
                        }

                        .container {
                            max-width: 1200px;
                            margin: 0 auto;
                            padding: 2rem;
                        }

                        header {
                            margin-bottom: 2rem;
                            padding-bottom: 1rem;
                            border-bottom: 1px solid #eee;
                        }

                        h1 {
                            font-size: 2.5rem;
                            margin-bottom: 1rem;
                            color: #2c3e50;
                        }

                        nav {
                            margin-bottom: 1rem;
                        }

                        main {
                            margin-bottom: 2rem;
                        }

                        footer {
                            text-align: center;
                            padding-top: 1rem;
                            border-top: 1px solid #eee;
                            color: #666;
                        }

                        /* Responsive design */
                        @media (max-width: 768px) {
                            .container {
                                padding: 1rem;
                            }

                            h1 {
                                font-size: 2rem;
                            }
                        }
                    """,
                    name="base.css",
                    size=1024,
                    mime_type="text/css",
                )
            ],
            AssetType.JAVASCRIPT: [
                Asset(
                    type=AssetType.JAVASCRIPT,
                    content="""
                        // Initialize interactive elements
                        document.addEventListener('DOMContentLoaded', function() {
                            // Add smooth scrolling
                            document.querySelectorAll('a[href^="#"]').forEach(anchor => {
                                anchor.addEventListener('click', function (e) {
                                    e.preventDefault();
                                    document.querySelector(this.getAttribute('href')).scrollIntoView({
                                        behavior: 'smooth'
                                    });
                                });
                            });

                            // Add mobile menu toggle
                            const menuToggle = document.querySelector('.menu-toggle');
                            if (menuToggle) {
                                menuToggle.addEventListener('click', function() {
                                    document.querySelector('nav').classList.toggle('active');
                                });
                            }
                        });
                    """,
                    name="main.js",
                    size=512,
                    mime_type="application/javascript",
                )
            ],
        }

    async def _generate_html(self, request: HTMLGenerationRequest) -> HTMLOutput:
        """
        Generate HTML output based on the request.
        Args:
            request: HTML generation request
        Returns:
            HTMLOutput: Generated HTML output
        """
        # Get template
        template = self._get_template(request.template_id)

        # Get module content
        module_content = await self._get_module_content(request.module_id)

        # Generate navigation
        navigation = self._generate_navigation(module_content)

        # Process content
        processed_content = self._process_content(module_content)

        # Get assets
        assets = self._get_assets(template)

        # Generate HTML
        html_content = template.content.format(
            title=module_content.get("title", "Learning Module"),
            styles=self._generate_styles(assets),
            navigation=navigation,
            content=processed_content,
            scripts=self._generate_scripts(assets),
        )

        # Calculate file size
        file_size = len(html_content.encode("utf-8"))

        return HTMLOutput(
            module_id=request.module_id,
            title=module_content.get("title", "Learning Module"),
            content=html_content,
            assets=assets,
            template_id=template.template_id,
            file_size=file_size,
            metadata={
                "generation_timestamp": datetime.utcnow().isoformat(),
                "customization": request.customization,
            },
        )

    def _get_template(self, template_id: Optional[UUID]) -> HTMLTemplate:
        """Get HTML template by ID or return default template."""
        if template_id:
            # TODO: Implement template lookup from database
            pass
        return self.templates["default"]

    async def _get_module_content(self, module_id: UUID) -> Dict[str, Any]:
        """Get module content from database."""
        # TODO: Implement module content retrieval
        return {
            "title": "Sample Module",
            "sections": [
                {
                    "title": "Introduction",
                    "content": "<p>Welcome to this learning module.</p>",
                }
            ],
        }

    def _generate_navigation(self, content: Dict[str, Any]) -> str:
        """Generate navigation menu from content."""
        sections = content.get("sections", [])
        nav_items = []

        for section in sections:
            title = section.get("title", "")
            if title:
                nav_items.append(f'<a href="#{self._slugify(title)}">{title}</a>')

        return f'<nav class="main-nav">{" ".join(nav_items)}</nav>'

    def _process_content(self, content: Dict[str, Any]) -> str:
        """Process and format content for HTML output."""
        sections = content.get("sections", [])
        processed_sections = []

        for section in sections:
            title = section.get("title", "")
            section_content = section.get("content", "")

            if title:
                processed_sections.append(f'<section id="{self._slugify(title)}">')
                processed_sections.append(f"<h2>{title}</h2>")
                processed_sections.append(section_content)
                processed_sections.append("</section>")

        return "\n".join(processed_sections)

    def _get_assets(self, template: HTMLTemplate) -> List[Asset]:
        """Get all assets for the template."""
        assets = []

        # Add template assets
        assets.extend(template.assets)

        # Add default assets
        for asset_type, type_assets in self.default_assets.items():
            assets.extend(type_assets)

        return assets

    def _generate_styles(self, assets: List[Asset]) -> str:
        """Generate style tags for CSS assets."""
        style_tags = []

        for asset in assets:
            if asset.type == AssetType.CSS:
                style_tags.append(f"<style>{asset.content}</style>")

        return "\n".join(style_tags)

    def _generate_scripts(self, assets: List[Asset]) -> str:
        """Generate script tags for JavaScript assets."""
        script_tags = []

        for asset in assets:
            if asset.type == AssetType.JAVASCRIPT:
                script_tags.append(f"<script>{asset.content}</script>")

        return "\n".join(script_tags)

    def _slugify(self, text: str) -> str:
        """Convert text to URL-friendly slug."""
        text = text.lower()
        text = re.sub(r"[^\w\s-]", "", text)
        text = re.sub(r"[-\s]+", "-", text)
        return text.strip("-")

    def _validate_html(self, output: HTMLOutput) -> HTMLValidationResult:
        """
        Validate generated HTML output.
        Args:
            output: HTML output to validate
        Returns:
            HTMLValidationResult: Validation results
        """
        issues = []
        suggestions = []

        # Check HTML structure
        if not output.content.startswith("<!DOCTYPE html>"):
            issues.append("Missing DOCTYPE declaration")
            suggestions.append("Add proper HTML5 DOCTYPE declaration")

        if "<html" not in output.content:
            issues.append("Missing HTML root element")
            suggestions.append("Add HTML root element")

        if "<head" not in output.content:
            issues.append("Missing head section")
            suggestions.append("Add head section with meta tags")

        if "<body" not in output.content:
            issues.append("Missing body section")
            suggestions.append("Add body section for content")

        # Check assets
        asset_count = len(output.assets)
        if asset_count == 0:
            issues.append("No assets included")
            suggestions.append("Add necessary CSS and JavaScript assets")

        # Check file size
        if output.file_size > 5 * 1024 * 1024:  # 5MB limit
            issues.append("File size exceeds recommended limit")
            suggestions.append("Optimize assets and content for smaller file size")

        # Check browser compatibility
        browser_compatibility = {
            "chrome": True,
            "firefox": True,
            "safari": True,
            "edge": True,
        }

        return HTMLValidationResult(
            output_id=output.output_id,
            is_valid=len(issues) == 0,
            issues=issues,
            suggestions=suggestions,
            file_size=output.file_size,
            asset_count=asset_count,
            browser_compatibility=browser_compatibility,
            metadata={"validation_timestamp": datetime.utcnow().isoformat()},
        )
